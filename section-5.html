<!DOCTYPE html>
<!--**************************************-->
<!--*    Generated from PreTeXt source   *-->
<!--*    on 2020-03-18T09:31:45-04:00    *-->
<!--*                                    *-->
<!--*      https://pretextbook.org       *-->
<!--*                                    *-->
<!--**************************************-->
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Interpolation</title>
<meta name="Keywords" content="Authored in PreTeXt">
<meta name="viewport" content="width=device-width,  initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">
<script src="https://sagecell.sagemath.org/embedded_sagecell.js"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['\\(','\\)']]
    },
    asciimath2jax: {
        ignoreClass: ".*",
        processClass: "has_am"
    },
    jax: ["input/AsciiMath"],
    extensions: ["asciimath2jax.js"],
    TeX: {
        extensions: ["extpfeil.js", "autobold.js", "https://pretextbook.org/js/lib/mathjaxknowl.js", ],
        // scrolling to fragment identifiers is controlled by other Javascript
        positionToHash: false,
        equationNumbers: { autoNumber: "none", useLabelIds: true, },
        TagSide: "right",
        TagIndent: ".8em",
    },
    // HTML-CSS output Jax to be dropped for MathJax 3.0
    "HTML-CSS": {
        scale: 88,
        mtextFontInherit: true,
    },
    CommonHTML: {
        scale: 88,
        mtextFontInherit: true,
    },
});
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_CHTML-full"></script><script>$(function () {
    // Make *any* div with class 'sagecell-sage' an executable Sage cell
    // Their results will be linked, only within language type
    sagecell.makeSagecell({inputLocation: 'div.sagecell-sage',
                           linked: true,
                           languages: ['sage'],
                           evalButtonText: 'Evaluate (Sage)'});
});
</script><script>$(function () {
    // Make *any* div with class 'sagecell-octave' an executable Sage cell
    // Their results will be linked, only within language type
    sagecell.makeSagecell({inputLocation: 'div.sagecell-octave',
                           linked: true,
                           languages: ['octave'],
                           evalButtonText: 'Evaluate (Octave)'});
});
</script><script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script><script src="https://pretextbook.org/js/lib/jquery.min.js"></script><script src="https://pretextbook.org/js/lib/jquery.sticky.js"></script><script src="https://pretextbook.org/js/lib/jquery.espy.min.js"></script><script src="https://pretextbook.org/js/0.12/pretext.js"></script><script src="https://pretextbook.org/js/0.12/pretext_add_on.js"></script><script src="https://pretextbook.org/js/lib/knowl.js"></script><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,400italic,600,600italic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.2/pretext.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.2/pretext_add_on.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.2/toc.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.2/colors_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.2/setcolors.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.2/features.css" rel="stylesheet" type="text/css">
<script>var logged_in = false;
var role = 'student';
var guest_access = true;
var login_required = false;
var js_version = 0.12;
</script>
</head>
<body class="mathbook-article has-toc has-sidebar-left">
<a class="assistive" href="#content">Skip to main content</a><div class="hidden-content" style="display:none">\(\DeclareMathOperator{\RE}{Re}
\DeclareMathOperator{\IM}{Im}
\DeclareMathOperator{\ess}{ess}
\DeclareMathOperator{\intr}{int}
\DeclareMathOperator{\dist}{dist}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator\re{\mathrm {Re~}}
\DeclareMathOperator\im{\mathrm {Im~}}
\newcommand\dd{\mathrm d}
\newcommand{\eps}{\varepsilon}
\newcommand{\To}{\longrightarrow}
\newcommand{\hilbert}{\mathcal{H}}
\newcommand{\s}{\mathcal{S}_2}
\newcommand{\A}{\mathcal{A}}
\newcommand\h{\mathcal{H}}
\newcommand{\J}{\mathcal{J}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\N}{\mathcal{N}}
\newcommand{\T}{\mathbb{T}}
\newcommand{\W}{\mathcal{W}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\D}{\mathbb{D}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\BOP}{\mathbf{B}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\BH}{\mathbf{B}(\mathcal{H})}
\newcommand{\KH}{\mathcal{K}(\mathcal{H})}
\newcommand{\pick}{\mathcal{P}_2}
\newcommand{\schur}{\mathcal{S}_2}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Complex}{\mathbb{C}}
\newcommand{\Field}{\mathbb{F}}
\newcommand{\RPlus}{\Real^{+}}
\newcommand{\Polar}{\mathcal{P}_{\s}}
\newcommand{\Poly}{\mathcal{P}(E)}
\newcommand{\EssD}{\mathcal{D}}
\newcommand{\Lop}{\mathcal{L}}
\newcommand{\cc}[1]{\overline{#1}}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\seq}[1]{\left\lt#1\right&gt;}
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
\newcommand{\essnorm}[1]{\norm{#1}_{\ess}}
\newcommand{\tr}{\operatorname{tr}}
\newcommand{\ran}[1]{\operatorname{ran}#1}
\newcommand{\nt}{\stackrel{\mathrm {nt}}{\to}}
\newcommand{\pnt}{\xrightarrow{pnt}}
\newcommand{\ip}[2]{\left\langle #1, #2 \right\rangle}
\newcommand{\ad}{^\ast}
\newcommand{\inv}{^{-1}}
\newcommand{\adinv}{^{\ast -1}}
\newcommand{\invad}{^{-1 \ast}}
\newcommand\Pick{\mathcal P}
\newcommand\Ha{\mathbb{H}}
\newcommand{\HH}{\Ha\times\Ha}
\newcommand\Htau{\mathbb{H}(\tau)}
\newcommand{\vp}{\varphi}
\newcommand{\ph}{\varphi}
\newcommand\al{\alpha}
\newcommand\ga{\gamma}
\newcommand\de{\delta}
\newcommand\ep{\varepsilon}
\newcommand\la{\lambda}
\newcommand\up{\upsilon}
\newcommand\si{\sigma}
\newcommand\beq{\begin{equation}}
\newcommand\ds{\displaystyle}
\newcommand\eeq{\end{equation}}
\newcommand\df{\stackrel{\rm def}{=}}
\newcommand\ii{\mathrm i}
\newcommand{\vectwo}[2]
{
   \begin{pmatrix} #1 \\ #2 \end{pmatrix}
}
\newcommand{\vecthree}[3]
{
   \begin{pmatrix} #1 \\ #2 \\ #3 \end{pmatrix}
}
\newcommand\blue{\color{blue}}
\newcommand\black{\color{black}}
\newcommand\red{\color{red}}
\newcommand\nn{\nonumber}
\newcommand\bbm{\begin{bmatrix}}
\newcommand\ebm{\end{bmatrix}}
\newcommand\bpm{\begin{pmatrix}}
\newcommand\epm{\end{pmatrix}}
\numberwithin{equation}{section}
\newcommand\nin{\noindent}
\newcommand{\nCr}[2]{\,_{#1}C_{#2}} 
\newcommand{\lt}{&lt;}
\newcommand{\gt}{&gt;}
\newcommand{\amp}{&amp;}
\)</div>
<header id="masthead" class="smallbuttons"><div class="banner"><div class="container">
<a id="logo-link" href=""></a><div class="title-container">
<h1 class="heading"><a href="minimal.html"><span class="title">Numerical Analysis</span></a></h1>
<p class="byline">Ryan Tully-Doyle</p>
</div>
</div></div>
<nav id="primary-navbar" class="navbar"><div class="container">
<div class="navbar-top-buttons">
<button class="sidebar-left-toggle-button button active" aria-label="Show or hide table of contents sidebar">Contents</button><div class="tree-nav toolbar toolbar-divisor-3"><span class="threebuttons"><a id="previousbutton" class="previous-button toolbar-item button" href="sec-root.html" title="Previous">Prev</a><a id="upbutton" class="up-button button toolbar-item" href="minimal.html" title="Up">Up</a><a id="nextbutton" class="next-button button toolbar-item" href="section-6.html" title="Next">Next</a></span></div>
</div>
<div class="navbar-bottom-buttons toolbar toolbar-divisor-4">
<button class="sidebar-left-toggle-button button toolbar-item active">Contents</button><a class="previous-button toolbar-item button" href="sec-root.html" title="Previous">Prev</a><a class="up-button button toolbar-item" href="minimal.html" title="Up">Up</a><a class="next-button button toolbar-item" href="section-6.html" title="Next">Next</a>
</div>
</div></nav></header><div class="page">
<div id="sidebar-left" class="sidebar" role="navigation"><div class="sidebar-content">
<nav id="toc"><ul>
<li class="link"><a href="frontmatter-1.html" data-scroll="frontmatter-1"><span class="title">Front Matter</span></a></li>
<li class="link"><a href="section-needs.html" data-scroll="section-needs"><span class="codenumber">1</span> <span class="title">What you need - Octave/Matlab</span></a></li>
<li class="link"><a href="section-review.html" data-scroll="section-review"><span class="codenumber">2</span> <span class="title">Motivation</span></a></li>
<li class="link">
<a href="sec-taylor.html" data-scroll="sec-taylor"><span class="codenumber">3</span> <span class="title">Taylor polynomials</span></a><ul>
<li><a href="sec-taylor.html#subsection-1" data-scroll="subsection-1">Taylor's theorem</a></li>
<li><a href="sec-taylor.html#subsection-2" data-scroll="subsection-2">What is a Taylor approximation good for?</a></li>
<li><a href="sec-taylor.html#subsection-3" data-scroll="subsection-3">Coding functions in Octave</a></li>
</ul>
</li>
<li class="link">
<a href="sec-root.html" data-scroll="sec-root"><span class="codenumber">4</span> <span class="title">Root finding</span></a><ul>
<li><a href="sec-root.html#sub-bisection" data-scroll="sub-bisection">Bisection method</a></li>
<li><a href="sec-root.html#subsection-5" data-scroll="subsection-5">Error</a></li>
<li><a href="sec-root.html#subsection-6" data-scroll="subsection-6">Bisection algorithm</a></li>
<li><a href="sec-root.html#subsection-7" data-scroll="subsection-7">False position (Regula Falsi)</a></li>
<li><a href="sec-root.html#subsection-8" data-scroll="subsection-8">Classes of differentiability</a></li>
<li><a href="sec-root.html#subsection-9" data-scroll="subsection-9">Newton-Raphson method</a></li>
<li><a href="sec-root.html#subsection-10" data-scroll="subsection-10">Newton's method requirements and problems</a></li>
</ul>
</li>
<li class="link active">
<a href="section-5.html" data-scroll="section-5"><span class="codenumber">5</span> <span class="title">Interpolation</span></a><ul>
<li><a href="section-5.html#subsection-11" data-scroll="subsection-11">Naive polynomial interpolation</a></li>
<li><a href="section-5.html#subsection-12" data-scroll="subsection-12">Lagrange interpolation</a></li>
<li><a href="section-5.html#subsection-13" data-scroll="subsection-13">Newton interpolation</a></li>
<li><a href="section-5.html#subsection-14" data-scroll="subsection-14">Problems with polynomials</a></li>
<li><a href="section-5.html#subsection-15" data-scroll="subsection-15">Spline interpolation</a></li>
<li><a href="section-5.html#subsection-16" data-scroll="subsection-16">Many-point spline interpolation example</a></li>
</ul>
</li>
<li class="link">
<a href="section-6.html" data-scroll="section-6"><span class="codenumber">6</span> <span class="title">Numerical Integration</span></a><ul>
<li><a href="section-6.html#subsection-17" data-scroll="subsection-17">Integration review</a></li>
<li><a href="section-6.html#subsection-18" data-scroll="subsection-18">The trapezoid rule</a></li>
<li><a href="section-6.html#subsection-19" data-scroll="subsection-19">A special case of Richardson's extrapolation (optional)</a></li>
<li><a href="section-6.html#subsection-20" data-scroll="subsection-20">Simpson's 1/3 rule</a></li>
</ul>
</li>
<li class="link">
<a href="section-7.html" data-scroll="section-7"><span class="codenumber">7</span> <span class="title">Introduction to Fourier Series (a linear algebra perspective)</span></a><ul>
<li><a href="section-7.html#subsection-21" data-scroll="subsection-21">Review of linear algebra</a></li>
<li><a href="section-7.html#subsection-22" data-scroll="subsection-22">The space \(L^2([-\pi,\pi])\)</a></li>
<li><a href="section-7.html#subsection-23" data-scroll="subsection-23">Example computation</a></li>
<li><a href="section-7.html#subsection-24" data-scroll="subsection-24">Complex numbers and Fourier series</a></li>
<li><a href="section-7.html#subsection-25" data-scroll="subsection-25">Introduction to the discrete Fourier transform</a></li>
<li><a href="section-7.html#subsection-26" data-scroll="subsection-26">Leakage and the DFT</a></li>
<li><a href="section-7.html#subsection-27" data-scroll="subsection-27">Octave and the DFT</a></li>
<li><a href="section-7.html#subsection-28" data-scroll="subsection-28">Going backwards - <code class="code-inline tex2jax_ignore">ifft</code></a></li>
</ul>
</li>
<li class="link">
<a href="section-8.html" data-scroll="section-8"><span class="codenumber">8</span> <span class="title">Code examples</span></a><ul><li><a href="section-8.html#subsection-29" data-scroll="subsection-29">Lab 1 - Introduction</a></li></ul>
</li>
<li class="link">
<a href="section-9.html" data-scroll="section-9"><span class="codenumber">9</span> <span class="title">Assignments</span></a><ul>
<li><a href="section-9.html#subsection-30" data-scroll="subsection-30">Assignment Set 1</a></li>
<li><a href="section-9.html#subsection-31" data-scroll="subsection-31">Assignment Set 2</a></li>
<li><a href="section-9.html#subsection-32" data-scroll="subsection-32">Assignment set 3</a></li>
<li><a href="section-9.html#subsection-33" data-scroll="subsection-33">Assignment set 4</a></li>
<li><a href="section-9.html#subsection-34" data-scroll="subsection-34">Assignment set 5 (including challenge set)</a></li>
<li><a href="section-9.html#subsection-35" data-scroll="subsection-35">Assignment set 6 - Newton polynomials</a></li>
<li><a href="section-9.html#subsection-36" data-scroll="subsection-36">Assignment set 7 - Cubic splines</a></li>
<li><a href="section-9.html#subsection-37" data-scroll="subsection-37">Assignment 8 - Numerical integration</a></li>
<li><a href="section-9.html#subsection-38" data-scroll="subsection-38">Assignment 9 - Fourier series</a></li>
</ul>
</li>
</ul></nav><div class="extras"><nav><a class="mathbook-link" href="https://pretextbook.org">Authored in PreTeXt</a><a href="https://www.mathjax.org"><img title="Powered by MathJax" src="https://www.mathjax.org/badge/badge.gif" alt="Powered by MathJax"></a></nav></div>
</div></div>
<main class="main"><div id="content" class="pretext-content"><section class="section" id="section-5"><h2 class="heading hide-type">
<span class="type">Section</span> <span class="codenumber">5</span> <span class="title">Interpolation</span>
</h2>
<section class="subsection" id="subsection-11"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">5.1</span> <span class="title">Naive polynomial interpolation</span>
</h3>
<p id="p-75">Given a set of points, say \(P(x_1, y_1), Q(x_2, y_2), R(x_3, y_3)\text{,}\) we say that a function \(f\) <dfn class="terminology">interpolates</dfn> \(P, Q, R\) if the graph of \(f\) passes through each prescribed point - that is, \(f(x_i) = y_i\) for each \(i = 1, \ldots 3\) in this case. The function \(f\) can be used to predict the values of \(y\) for values of \(x\) that fall in between these points. (Predicting points outside of the data is called <dfn class="terminology">extrapolation</dfn>.)</p>
<p id="p-76">A first approach to this problem might take advantage of the following fact. <article class="theorem-like" id="theorem-4"><h6 class="heading">
<span class="type">Theorem</span> <span class="codenumber">5.1</span>.</h6>
<p id="p-77">Let \(p_1, \ldots, p_n\) be non-collinear. Then there is a unique polynomial of degree \(n -1\) that interpolates the data.</p></article> One possible proof of this fact is the construction of the Lagrange polynomials, to be discussed in the next section.</p>
<p id="p-78">So suppose that we are given the points \((1,1), (2,-3), (5,10)\text{.}\) A quick plot shows that they are clearly non-collinear. Thus, there should exist a degree two polynomial that interpolates the points, which will have the general form</p>
<div class="displaymath">
\begin{equation*}
y = ax^2 + bx + c.
\end{equation*}
</div>
<p id="p-79">The unknowns we need to find are the coefficients \(a, b, c\text{.}\) So we'll plug in the known data and get a system of equations.</p>
<div class="displaymath">
\begin{align*}
1 \amp= a + b + c\\
-3 \amp = 4a + 2b + c\\
10 \amp= 25a + 5b + c
\end{align*}
</div>
<p id="p-80">We can solve the system using matrices.</p>
<div class="sagecell-octave" id="sage-24"><script type="text/x-sage">A = [1, 1, 1, 1;  4, 2, 1, -3; 25, 5, 1, 10]
B = rref(A)
</script></div>
<p id="p-81">Doing this by hand would be potentially very time consuming, particularly if we had to work with many points, not just three. Our result says that the approximate polynomial that interpolates the data is</p>
<div class="displaymath">
\begin{equation*}
f(x) = 2.08333 x^2 - 10.25 x + 9.16667.
\end{equation*}
</div>
<p>Note that this polynomial is unique (up to approximation error). That is, any other technique that finds a degree two polynomial through these three points will find the same result.</p>
<p id="p-82">In the next few sections, we will discuss two more interpolation techniques, one that is very easy for humans to understand (and evaluate with a little modification in certain cases) and one that is easy to program into a computer technique.</p>
<figure class="figure-like" id="figure-1"><div class="sagecell-octave" id="sage-25"><script type="text/x-sage">f = @(x) 2.08333* x.^2 - 10.25 *x + 9.16667;
X = 0:.01:6;
Y = f(X);
plot([1, 2, 5],[1, -3, 10], 'b*')
hold on
plot(X,Y, 'r')
</script></div>
<figcaption><span class="type">Figure</span> <span class="codenumber">5.2.</span> Data and interpolating function example</figcaption></figure></section><section class="subsection" id="subsection-12"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">5.2</span> <span class="title">Lagrange interpolation</span>
</h3>
<p id="p-83">We'll begin with a method due to Lagrange that makes it very easy to write down by hand what the interpolating polynomal is (but doesn't give it in a computationally efficient form). Still, Lagrange interpolation is based on fundamental observations about the graphs of functions.</p>
<p id="p-84">Suppose that we are given the points \((1,0), (2,0), (5,0)\) and we are asked to provide an interpolating polynomial of degree two (these points are collinear, but they very soon won't be). One obvious choice is to form the polynomial</p>
<div class="displaymath">
\begin{equation*}
p(x) = (x - 1)(x - 2)(x - 5).
\end{equation*}
</div>
<p>This polynomial is not a unique polynomial of degree two, but it certainly interpolates them. We are going to use the idea of interpolating roots, as we've done here, to build interpolating functions for data off of the \(x\)-axis.</p>
<p id="p-85">This exercise can be made slightly harder by allowing one of the points to move off of the \(x\)-axis. Now consider the points \((1,0),(2,0), (5,10)\text{.}\) Ignoring the third point for the moment, we can still interpolate \((1,0), (2,0)\) in the same way as before: with \(p(x) = (x -1)(x-2)\text{.}\) Maybe we're lucky and \(p\) also passes through \((5,10)\text{.}\) We can check -- \(p(5) = (5-1)(4-1) = 12\text{.}\) That is, \(p\) misses \((5,10)\text{.}\)</p>
<div class="sagecell-octave" id="sage-26"><script type="text/x-sage">f = @(x) (x - 1).*(x-2);
X = 0:.01:6;
Y = f(X);
plot([1, 2, 5],[0, 0, 10], 'b*')
hold on
plot(X,Y, 'r')
</script></div>
<p id="p-86">What we need is a way to adjust \(p\) that keeps the function passing through \((1,0)\) and \((2,0)\text{.}\) We might notice that every function of the form \(f(x) = c(x-1)(x-2) = c\cdot p(x)\) has this property, so let's choose a value of \(c\) that makes \(f\) pass through \((5,10)\text{.}\)</p>
<div class="displaymath">
\begin{align*}
10 \amp= f(5) = c\cdot p(5) = c(5-1)(5-4) = 12c\\
\frac{10}{12} \amp= c.
\end{align*}
</div>
<p>So \(f(x) = \frac{10}{12} p(x) = \frac{10}{12} (x-1)(x-2)\) interpolates the data.</p>
<div class="sagecell-octave" id="sage-27"><script type="text/x-sage">f = @(x) 10/12*(x - 1).*(x-2);
X = 0:.01:6;
Y = f(X);
plot([1, 2, 5],[0, 0, 10], 'b*')
hold on
plot(X,Y, 'r')
</script></div>
<p id="p-87">Now, notice that 10 was the value we wanted to be output with input 5, and that \(p(5) = 12\text{.}\) In fact, if \((5,10)\) had been given the name \((x_3, y_3)\text{,}\) then the value of \(c\) would have been \(c = \frac{y_3}{p(x_3)},\) and the interpolating function for \((1,0), (2,0)\) and \((x_3, y_3)\) would have been</p>
<div class="displaymath">
\begin{equation*}
f(x) = \frac{y_3}{p(x_3)} p(x) = \frac{y_3}{p(x_3)} (x - 1)(x-2).
\end{equation*}
</div>
<p>We can modify this further: given initial data \((x_1, 0), (x_2, 0), (x_3, y_3)\text{,}\) define</p>
<div class="displaymath">
\begin{equation*}
p(x) = (x - x_1)(x - x_2)
\end{equation*}
</div>
<p>and</p>
<div class="displaymath">
\begin{equation*}
f(x) = \frac{y_3}{p(x_3)} p(x) = \frac{y_3}{p(x_3)}(x - x_1)(x-x_2).
\end{equation*}
</div>
<p>\(f\) is the interpolating function for the data.</p>
<p id="p-88">We're finally ready to tackle the full problem: using this approach to find the interpolating polynomial for \((1,1), (2, -3), (5,10)\text{.}\) We'll approach the problem in three pieces: First, construct \(f_3(x)\) for the points \((1,0), (2,0), (5,10)\) using the ideas from the last section.</p>
<div class="displaymath">
\begin{equation*}
f_3(x) = \frac{10}{12} (x-1)(x-2).
\end{equation*}
</div>
<p id="p-89">Second, construct \(f_2(x)\) for the points \((1,0), (2, -3), (5,0).\) Since \(p_2(x) = (x-1)(x-5)\text{,}\) we get \(c = \frac{-3}{p_2(2)} = \frac{-3}{-3} = 1\text{.}\) So</p>
<div class="displaymath">
\begin{equation*}
f_2(x) = 1(x - 1)(x-5)
\end{equation*}
</div>
<p>interpolates this data.</p>
<p id="p-90">For a third step, construct \(f_1(x)\) for the points \((1,1), (2,0), (5,0)\text{.}\) In this problem, \(p_1(x) = (x-2)(x-5)\text{,}\) and so \(c = \frac{1}{p(1)} = \frac{1}{4}\text{.}\) Thus,</p>
<div class="displaymath">
\begin{equation*}
f_1(x) = \frac{1}{4} (x - 2)(x -5).
\end{equation*}
</div>
<p id="p-91">What follows is a plot of the three solutions to the subproblems.</p>
<div class="sagecell-octave" id="sage-28"><script type="text/x-sage">f3 = @(x) 10/12*(x - 1).*(x - 2);
f2 = @(x) (x - 1).*(x-5);
f1 = @(x) 1/4*(x-2).*(x-5);
X = 0:.01:6;
plot(X, f1(X), X, f2(X), X, f3(X))
hold on
plot([1, 2, 5],[1, -3, 10], 'b*')
plot([1, 2, 5],[0,0,0], 'r*')
set(gca,'xaxislocation','origin')
set(gca, 'yaxislocation','origin')
</script></div>
<p id="p-92">You should notice that each parabola passes through one of the real points and two of the substituted roots. We are at the magic step. Let</p>
<div class="displaymath">
\begin{equation*}
f = f_1 + f_2 + f_3.
\end{equation*}
</div>
<div class="sagecell-octave" id="sage-29"><script type="text/x-sage">f3 = @(x) 10/12*(x - 1).*(x - 2);
f2 = @(x) (x - 1).*(x-5);
f1 = @(x) 1/4*(x-2).*(x-5);
f = @(x) f1(x) + f2(x) + f3(x)
X = 0:.01:6;
plot(X, f(X))
hold on
plot([1, 2, 5],[1, -3, 10], 'b*')
plot([1, 2, 5],[0,0,0], 'r*')
set(gca,'xaxislocation','origin')
set(gca, 'yaxislocation','origin')
</script></div>
<p id="p-93">What happened? Let's look at \(f\) more closely.</p>
<div class="displaymath">
\begin{equation*}
f(x) = \frac{1}{4}(x - 2)(x - 5) + (x-1)(x-5) + \frac{10}{12}(x-1)(x-2).
\end{equation*}
</div>
<p>Notice that for a given input for one of the data points, only one term is non-zero, and that term has been built to evaluate to the correct \(y\)-value. That is,</p>
<div class="displaymath">
\begin{align*}
f(1) \amp= \frac{1}{4}(-1)(-4) + 0 + 0 = 1\\
f(2) \amp= 0 + (1)(-3) + 0 = -3\\
f(5) \amp= 0 + 0 + \frac{10}{12}(3)(4) = 10
\end{align*}
</div>
<p>Furthermore, \(f\) must be unique, because \(f\) is a degree two polynomial. (In fact, \(f\) is the same function from the previous section if you multiply it out.)</p>
<p id="p-94">So what is the general procedure? Start with a list of interpolants, \((x_1, y_1), \ldots, (x_n, y_n)\text{.}\) For each \(i\text{,}\) let</p>
<div class="displaymath">
\begin{equation*}
p_i(x) = \prod_{j\neq i} (x - x_j) = (x - x_1)\ldots(x - x_{i-1})(x-x_{i+1})\ldots(x - x_n).
\end{equation*}
</div>
<p>Then define \(f_i\) to be</p>
<div class="displaymath">
\begin{equation*}
f_i(x) = \frac{y_i}{p_i(x_i)} p_i(x),
\end{equation*}
</div>
<p>and finally the <dfn class="terminology">Lagrange interpolating polynomial</dfn> to be</p>
<div class="displaymath">
\begin{equation*}
f(x) = \sum_i f_i(x) = f_1(x) + \ldots + f_n(x).
\end{equation*}
</div></section><section class="subsection" id="subsection-13"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">5.3</span> <span class="title">Newton interpolation</span>
</h3>
<p id="p-95">Lagrange interpolation is easy to describe and relatively easy to write out by hand, even for many point, with some practice. However, the computation of the Lagrange interpolating polynomial doesn't easily lend itself to the structure of computer programs. We would like a method for writing down an interpolating polynomial that can be performed in a straightforward way in a recursive fashion. The approach that we present here is called <dfn class="terminology">Newton interpolation</dfn>. Of course, the result will be the same, as interpolating polynomials of degree \(n-1\) are unique for a given set of \(m\) points.</p>
<p id="p-96">Suppose that we're given two points, \((x_0, y_0), (x_1, y_1)\text{.}\) The lowest degree polynomial \(f\) through the first point is the horizontal line \(f(x) = y_0 = f(x_0)\text{.}\) The lowest degree polynomial \(f\) through the two points is</p>
<div class="displaymath">
\begin{equation*}
y = y_0 + \frac{y_1 - y_0}{x_1 - x_0}(x - x_0).
\end{equation*}
</div>
<p>We call the quantities \(y_0\) and \(\frac{y_1 - y_0}{x_1 - x_0}\) <dfn class="terminology">divided differences.</dfn> So now lets see what happens with three points.</p>
<p id="p-97">Suppose that we're given three points to interpolate, \((x_0,y_0), (x_1, y_1), (x_2, y_2)\text{.}\) We claim that we can construct a unique quadratic polynomial that interpolates the data of the form</p>
<div class="displaymath">
\begin{equation*}
f(x) = b_0 + b_1 (x - x_0) + b_2 (x - x_0)(x - x_1),
\end{equation*}
</div>
<p>for some as yet unknown constants \(b_0, b_1, b_2\) that depend on the points. (You can easily show that for noncollinear points, you get a nonsingular coefficient matrix for the resulting system, which implies a unique solution.)</p>
<p id="p-98">To find the values of the coefficients, we'll plug in our data points.</p>
<div class="displaymath">
\begin{equation*}
f(x_0) = b_0 + 0 + 0
\end{equation*}
</div>
<p>and so \(b_0 = f(x_0) = y_0\text{.}\) Moving to \(x_1\text{,}\)</p>
<div class="displaymath">
\begin{align*}
f(x_1) \amp= b_0 + b_1(x_1 - x_0) + 0\\
y_1 \amp= y_0 + b_1(x_1 - x_0)\\
b_1 \amp= \frac{y_1 - y_0}{x_1 - x_0}
\end{align*}
</div>
<p>Notice that so far, we've exactly reproduced the line connecting the first two points. Now let's look at \(b_2\text{.}\)</p>
<div class="displaymath">
\begin{align*}
f(x_2) \amp= y_0 + \frac{y_1 - y_0}{x_1 - x_0}(x_2 - x_0) + b_2 (x_2 - x_0)(x_2 - x_1)\\
y_2 \amp- y_0 - \frac{y_1 - y_0}{x_1 - x_0}(x_2 - x_0) = b_2 (x_2 - x_0)(x_2 - x_1)\\
b_2 \amp= \frac{\frac{y_2 - y_1}{x_2 - x_1} - \frac{y_1 - y_0}{y_1 - y_0}}{x_2 - x_0},
\end{align*}
</div>
<p>where the last step requires a bit of non-obvious algebra, but provides a more useful form.</p>
<p id="p-99">It turns out that this process can be repeated for additional points, though one can imagine the formula for the next step is quite complicated to express in \(x_i, y_i\text{.}\) So we introduce a notation that will make this process easy to write in recursive form. The \(m\)th divided difference is given by the recursive formula</p>
<div class="displaymath">
\begin{align*}
f[x_i] \amp= y_i;\\
f[x_m, \ldots, x_0] \amp= \frac{f[x_m, \ldots, x_1] - f[x_{m-1}, \ldots, x_0]}{x_m - x_0}.
\end{align*}
</div>
<p>For example, in this notation,</p>
<div class="displaymath">
\begin{equation*}
f[x_1, x_0] = \frac{f[x_1] - f[x_0]}{x_1 - x_0} = \frac{y_2 - y_1}{x_2 - x_1},
\end{equation*}
</div>
<p>and you should convince yourself that the expression for \(f[x_2, x_1, x_0]\) agrees with our previous computation.</p>
<p id="p-100">We want to use this approach because we'd prefer our computations to be purely in terms of array entries, not the application of general formulas. As an example, we will trace through the example of computing the coefficients of the Newton polynomial for the points \((1,1), (2, 3), (5,10)\) in code.</p>
<div class="sagecell-octave" id="sage-30"><script type="text/x-sage">nodeX = [1, 2, 5];
nodeY = [1, 3, 10];
#this section calculates the coefficients
data = zeros(3); #3x3 matrix of 0s
for i = 1:3
    data(1,i) = nodeY(i)
endfor
for i = 1:2
    data(2,i) = (data(1,i+1) - data(1,i))/(nodeX(i+1)-nodeX(i));
endfor
for i = 1:1
    data(3,i) = (data(2,i+1)- data(2,i))/(nodeX(i+2) - nodeX(i));
endfor
b = data(:,1)'
#this section creates the Newton polynomial. It is unenlightening at the moment, because I am trying to avoid using symbolic variables. To be rewritten.
structure = @(x, b) b(1) + b(2)*(x - nodeX(1)) + b(3)*(x - nodeX(1)).*(x - nodeX(2));
poly = @(x) structure(x, b);
scatter(nodeX, nodeY, 400)
hold on
plot(0:.01:6, poly(0:.01:6))
</script></div>
<p id="p-101">The code above should provide an example of how to implement the recursion without having to rely on increasingly complex formulas to compute the coefficients. As a goal, one could try to produce all of the data in the matrix “data” in one loop, instead of the many loops that I have (suggestively) used. One could also write a much more revealing computation of the final polynomial.</p></section><section class="subsection" id="subsection-14"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">5.4</span> <span class="title">Problems with polynomials</span>
</h3>
<p id="p-102">Polynomial interpolation has a serious drawback in many cases: high degree polynomials can behave wildly between points in a way that doesn't reflect the expected behavior of the underlying function. To see this, consider the function</p>
<div class="displaymath">
\begin{equation*}
f(x) = \frac{1}{x^2 + 25}
\end{equation*}
</div>
<p>which is a typical example of a rational function with no vertical asymptotes. <div class="sagecell-octave" id="sage-31"><script type="text/x-sage">X = -1:.01:1;
f = @(x) 1./(1 + 25*x.^2);
plot(X, f(X))
set(gca,'xaxislocation','origin')
set(gca, 'yaxislocation','origin')
</script></div></p>
<p id="p-103">We will sample this function and then attempt to reconstruct it using polynomial interpolation. Suppose that we choose six equally spaced points from \(f\text{.}\) <div class="sagecell-octave" id="sage-32"><script type="text/x-sage">X = -1:.01:1;
f = @(x) 1./(1 + 25*x.^2);

P = [-1, -.6, -.2, .2, .6, 1];


plot(X, f(X))
set(gca,'xaxislocation','origin')
set(gca, 'yaxislocation','origin')
hold on
scatter(P, f(P), 400)
</script></div> Now suppose we find the unique polynomial that goes through these six points. (The code here uses the command polyfit.) <div class="sagecell-octave" id="sage-33"><script type="text/x-sage">X = -1:.01:1;
f = @(x) 1./(1 + 25*x.^2);

P = [-1, -.6, -.2, .2, .6, 1];


scatter(P, f(P), 400)
set(gca,'xaxislocation','origin')
set(gca, 'yaxislocation','origin')
hold on

plot(X, f(X))
p = polyfit(P, f(P), 5)
plot(X, polyval(p,X))
</script></div> Notice that the interpolating polynomial doesn't appear to behave like the original function at all, oscillating through the end points. Perhaps we can fix the problem by choosing more points.</p>
<div class="sagecell-octave" id="sage-34"><script type="text/x-sage">X = -1:.01:1;
f = @(x) 1./(1 + 25*x.^2);

Q = -1:.2:1;

scatter(Q, f(Q), 400)
set(gca,'xaxislocation','origin')
set(gca, 'yaxislocation','origin')
hold on

plot(X, f(X))
q = polyfit(Q, f(Q), 11)
plot(X, polyval(q,X))
</script></div>
<p id="p-104">Unfortunately, this seems to have exacerbated the problem. The polynomial starts to oscillate wildly and to grow sharply between nodes near the outside of the domain.  It turns out that this behavior is common in high degree polynomial interpolation of equally-spaced points. Replacing a complicated function with a polynomial interpolant isn't going to be as easy as sampling equidistant points, and we should expect that similar bad behavior is going to crop up in data sets with many points if we use a unique polynomial fit.</p>
<p id="p-105">There are many approaches to dealing with this undesirable behavior. In the next section, we'll talk about building smooth curves that pass through all of the points by considering them three at a time. In this section, we should at least be aware of better sampling methods that underlie much of modern approximation theory. Note that this is only a flavor - approximation theory is a huge field with myriad applications and techniques.</p>
<p id="p-106">One way that we can try to make a better approximating polynomial for a function is to sample more points near the edge - this should allow us to control the bad behavior that seems to occur there. But how should we pick the points? For various reasons, it turns out that a natural choice for sampling nodes (that is, the \(x\)-values that we'll use to sample the function we're trying to approximate) is the so-called <dfn class="terminology">Chebyshev nodes</dfn>, which correspond to the \(x\) coordinates of equally spaced points on a unit circle.</p>
<div class="sagecell-octave" id="sage-35"><script type="text/x-sage">n = 11;
nodes = cos(pi/n*((1:n)-.5));
X = -1:.01:1;
f = @(x) sqrt(1 - x.^2)
scatter(nodes, zeros(length(nodes),1), 400)
hold on
scatter(nodes, f(nodes), 400)
plot(X, f(X))
set(gca,'xaxislocation','origin')
set(gca, 'yaxislocation','origin')
</script></div>
<p id="p-107">The following code will compare high degree approximations of \(f\) using equally spaced and Chebyshev nodes</p>
<div class="sagecell-octave" id="sage-36"><script type="text/x-sage">X = -1:.01:1;
f = @(x) 1./(1 + 25*x.^2);

n = 11;
nodes = cos(pi/n*((1:n)-.5));
m = 21;
nodes2 = cos(pi/m*((1:m)-.5));


Q = -1:.2:1;
QQ = -1:.1:1;

l = polyfit(Q, f(Q), length(Q)-1);
p = polyfit(nodes, f(nodes), n-1);

ll = polyfit(QQ, f(QQ), length(QQ)-1);
pp = polyfit(nodes2, f(nodes2), m-1);

subplot(2, 2, 1)
scatter(Q, f(Q), 400)
set(gca,'xaxislocation','origin')
set(gca, 'yaxislocation','origin')
axis([-1 1 -1 1])
title("Poly. intepolation on equidistant nodes, n = 11")
hold on
plot(X, f(X))
plot(X, polyval(l,X))
hold off
subplot(2, 2, 2)
scatter(nodes, f(nodes), 400)
set(gca,'xaxislocation','origin')
set(gca, 'yaxislocation','origin')
axis([-1 1 -1 1])
hold on
plot(X, f(X))
plot(X, polyval(p,X))
title("Poly. interpolation on Chebyshev nodes, n = 11")
subplot(2, 2, 3)
scatter(QQ, f(QQ), 400)
set(gca,'xaxislocation','origin')
set(gca, 'yaxislocation','origin')
title("Poly. intepolation on equidistant nodes, n = 21")
axis([-1 1 -1 1])
hold on
plot(X, f(X))
plot(X, polyval(ll,X))
hold off
subplot(2, 2, 4)
scatter(nodes2, f(nodes2), 400)
set(gca,'xaxislocation','origin')
set(gca, 'yaxislocation','origin')
axis([-1 1 -1 1])
hold on
plot(X, f(X))
plot(X, polyval(pp,X))
title("Poly. interpolation on Chebyshev nodes, n = 21")
hold off
</script></div></section><section class="subsection" id="subsection-15"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">5.5</span> <span class="title">Spline interpolation</span>
</h3>
<p id="p-108">Instead of trying to force a high degree polynomial to fit through many points, if we want an interpolating function that has smooth properties, we could consider a piecewise approach instead. That is, instead of a single formula that interpolates all of the points, we'll construct small segments that join together into a smooth(ish) function that changes definition as we move down the set of data points. Piecewise interpolation is usually done in early math classes with a ruler connecting points with lines - a more sophisticated name for this is linear interpolation. Because a given line only has two parameters (slope and intercept), the best we can expect is to meet two conditions - that is, the line passes through each of two points.</p>
<p id="p-109">This is reflective of a general principle in mathematics that gets used but not often mentioned throughout college level courses - to meet one condition, an equation or set of equations needs one free parameter. In this case, since we're working with simultaneous equations, essentially we're using the invertible matrix theorem from linear algebra to guarantee a unique solutions.</p>
<p id="p-110">What we're going to present is a method that breaks a set of data points into consecutive groups of two points. We'll need an interpolating function piece with at least two free parameters that can be chosen. Since we want the curve to be differentiable, we'll need each segment to meet the next with the same slope - that is, we need the first derivatives to match every time we change segments. With \(n+1\) points, that means we have \(n-1\) points that are connections (that is, not the endpoints of the data set). Since we're dictating a condition on derivatives, we know that we'll need at least three parameters. In order to make the changes between the segments curve naturally (which is important in many physical applications), we also want the second derivatives to match. (This is essentially dictating that the curvatures of the segments match, or more geometrically that there is an osculating circle where two pieces meet.) So each segment is actually dealing with four restrictions, and thus we need a function with four free parameters - a cubic polynomial fits the bill!</p>
<p id="p-111">Where are we at? Suppose that we have \(n + 1\) points to interpolate. Then there are \(n\) segments, which requires \(n\) functions. Each segment has an associated cubic polynomial with 4 parameters, so there are \(4n\) parameters available. How many restrictions are there?</p>
<ul class="disc">
<li id="li-22">Two points to interpolate for each segment, so \(2n\) conditions.</li>
<li id="li-23">\(n-1\) points at which derivatives match.</li>
<li id="li-24">\(n - 1\) points at which second derivatives match.</li>
</ul>
<p id="p-112">So far, we have \(4n\) parameters and \(2n + n - 1 + n - 1 = 4n -2\) conditions. Where are the last two conditions going to come from? The endpoints! Since we have two available conditions to impose, we'll get a nice square system if we impose them on the endpoints. There are a couple of common choices for how to do this. The first is called a <dfn class="terminology">natural spline</dfn>, which is the case where the function has no curvature at the endpoints - that is, it's locally linear:</p>
<div class="displaymath">
\begin{equation*}
f''(x_1) = f''(x_{n+1}) = 0.
\end{equation*}
</div>
<p>In some physical applications, the designer of the spline might want to have prescribed slopes at the endpoints instead. That is,</p>
<div class="displaymath">
\begin{equation*}
f'(x_1) = c_1, \hspace{.5in} f'(x_{n+1}) = c_2.
\end{equation*}
</div>
<p id="p-113">Let's take a look at a small example to see how spline fitting works in practice. Suppose we're given three points, \((1,2), (2,4), (3,1)\text{.}\) Note that these are arranged in order of ascending \(x\) values. For each pair of points, we need a cubic spline - that is functions</p>
<div class="displaymath">
\begin{align*}
f_1(x) \amp= a_1 x^3 + b_1 x^2 + c_1 x + d_1,\\
f_2(x) \amp= a_2 x^3 + b_2 x^2 + c_2 x + d_2.
\end{align*}
</div>
<p>We'll organize the equations as above. First, we have the interpolating conditions (that is, the functions need to pass through the points.)</p>
<div class="displaymath">
\begin{align*}
a_1  + b_1 + c_1 + d_1 \amp= 2\\
8 a_1  + 4 b_1 + 2 c_1 + d_1 \amp= 4\\
8 a_2  + 4 b_2 + 2 c_2 + d_2 \amp= 4\\
27 a_2  + 9 b_2 + 3 c_2 + d_2 \amp= 1
\end{align*}
</div>
<p>Second, we want first derivatives to match at the transition point at \((2,4)\text{.}\)</p>
<div class="displaymath">
\begin{equation*}
12 a_1 + 4 b_1 + c_1 = 12 a_2 + 4 b_2 + c_2
\end{equation*}
</div>
<p>Third, we want second derivatives to match at \((2,4)\text{.}\)</p>
<div class="displaymath">
\begin{equation*}
12 a_1 + 2 b_1 = 12 a_2 + 2 b_2
\end{equation*}
</div>
<p>Finally, we impose the endpoint condition for a natural spline, which is that \(f''(x_1) = f''(x_n) = 0\text{:}\)</p>
<div class="displaymath">
\begin{gather*}
6 a_1 + 2 b_1 = 0\\
18 a_2 + 2 b_2 = 0
\end{gather*}
</div>
<p id="p-114">There are various algebraic approaches to solving splines that we will not consider here. Instead, we will try to organize these equations into a matrix form.</p>
<div class="displaymath">
\begin{equation*}
\bbm 1 \amp 1 \amp 1 \amp 1 \amp 0 \amp 0 \amp 0 \amp 0  \\
8 \amp 4 \amp 2 \amp 1 \amp 0 \amp 0\amp 0\amp 0 \\
0 \amp 0\amp 0\amp 0\amp 8 \amp 4\amp 2\amp 1 \\
0 \amp 0 \amp 0 \amp 0 \amp 27 \amp 9 \amp 3 \amp 1 \\
12 \amp 4 \amp 1 \amp 0 \amp -12 \amp -4 \amp -1 \amp 0 \\
12 \amp 2 \amp 0 \amp 0 \amp -12 \amp -2 \amp 0 \amp 0 \\
6 \amp 2 \amp 0 \amp 0 \amp 0 \amp 0 \amp 0 \amp 0 \\
0 \amp 0 \amp 0 \amp 0 \amp 18 \amp 2 \amp 0 \amp 0
\ebm \bbm a_1 \\ b_1 \\ c_1 \\ d_1 \\ a_2 \\ b_2 \\ c_2 \\ d_2 \ebm = \bbm 2 \\ 4 \\ 4 \\ 1 \\ 0 \\ 0 \\ 0 \\ 0 \ebm
\end{equation*}
</div>
<p id="p-115">At this point, we can solve the system using octave and row reduction. As long as there are no three consecutive points that are collinear, this system will have a unique solution (that is, the coefficient matrix is invertible). <div class="sagecell-octave" id="sage-37"><script type="text/x-sage">system = [1,1,1,1,0,0,0,0,2;8,4,2,1,0,0,0,0,4;0,0,0,0,8,4,2,1,4;0,0,0,0,27,9,3,1,1;12,4,1,0,-12,-4,-1,0,0;12,2,0,0,-12,-2,0,0,0;6,2,0,0,0,0,0,0,0;0,0,0,0,6,2,0,0,0];
coeefs = rref(system)(:,9) #this row reduces the system and takes the answer column, which is column 9
f1 = coeefs(1:4)'; #these take the coefficients associated with the first and second spline
f2 = coeefs(5:8)'; #and put the polynomials in vector form
X1 = 1:.01:2;
X2 = 2:.01:3;
Y1 = polyval(f1, X1);#evaluates each spline segment on the correct domain
Y2 = polyval(f2, X2);
plot(X1, Y1, 'r', X2, Y2, 'b')
hold on
scatter([1,2,3],[2,4,1],400) #plots the original points.
</script></div></p>
<p id="p-116">Next is a quick code demonstration of the addition of one more points, say at \((4,10)\text{.}\) You should look for the pattern in the equation sets, as this should give a clue about how to implement a general routine. By way of comparison, we will also plot the unique cubic that passes through the four points. You should note that the purple graph makes wider oscillations between the points than the multi-colored spline fit. <div class="sagecell-octave" id="sage-38"><script type="text/x-sage">system = [1,1,1,1,0,0,0,0,0,0,0,0,2;
           8,4,2,1,0,0,0,0,0,0,0,0,4;
           0,0,0,0,8,4,2,1,0,0,0,0,4;
           0,0,0,0,27,9,3,1,0,0,0,0,1;
           0,0,0,0,0,0,0,0,27,9,3,1,1;
           0,0,0,0,0,0,0,0,64, 16, 4, 1, 10;
           12,4,1,0,-12,-4,-1,0,0,0,0,0,0;
           0,0,0,0,27,6,1,0,-27,-6,-1,0,0;
           12,2,0,0,-12,-2,0,0,0,0,0,0,0;
           0,0,0,0,18, 2, 0,0, -18, -2, 0,0,0;
           6,2,0,0,0,0,0,0,0,0,0,0,0;
           0,0,0,0,0,0,0,0,24,2,0,0,0];
coeefs = rref(system)(:,13) #this row reduces the system and takes the answer column, which is column 9
f1 = coeefs(1:4)'; #these take the coefficients associated with the first and second spline
f2 = coeefs(5:8)'; #and put the polynomials in vector form
f3 = coeefs(9:12)';
X1 = 1:.01:2;
X2 = 2:.01:3;
X3 = 3:.01:4;
Y1 = polyval(f1, X1);#evaluates each spline segment on the correct domain
Y2 = polyval(f2, X2);
Y3 = polyval(f3,X3);

X = 1:.01:4;
f = polyfit([1,2,3,4],[2,4,1,10],3);
Y = polyval(f,X);

plot(X1, Y1, X2, Y2, X3, Y3, X, Y)
hold on
scatter([1,2,3,4],[2,4,1,10],400) #plots the original points.
</script></div></p></section><section class="subsection" id="subsection-16"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">5.6</span> <span class="title">Many-point spline interpolation example</span>
</h3>
<div class="sagecell-octave" id="sage-39"><script type="text/x-sage">#The first section samples the function g.

g = @(x) sin(x)
testX = -10:1:10;
testY = g(testX);
points = [testX; testY];
%points = [1, 2, 3,4, 8; 10, 3, -2,-1,7];
n = length(points(1,:))
f = @(x) [x.^3, x.^2, x, 1];
fprime = @(x) [3.*x.^2, 2.*x, 1, 0];
fpprime = @(x) [6.* x, 2, 0, 0];

#The second section constructs a matrix representing the system of linear equations needed to construct the interpolating polynomials

coeff = [];
b = [];
zeroblock = [0,0,0,0];

%interpolation rows
for i = 1:(n-1)
    currentrow = [];
    j = i;
    while (j-1)>0
        currentrow = [currentrow, zeroblock];
        j = j -1;
    endwhile
    currentrow = [currentrow, f(points(1,i))];
    k = i;
    while (n - 2 - (k-1))>0
        currentrow = [currentrow, zeroblock];
        k = k+1;
    endwhile
    coeff = [coeff;currentrow];
    b = [b;points(2,i)];
endfor

for i = 1:(n-1)
    currentrow = [];
    j = i;
    while (j-1)>0
        currentrow = [currentrow, zeroblock];
        j = j -1;
    endwhile
    currentrow = [currentrow, f(points(1,i+1))];
    k = i;
    while (n - 2 - (k-1))>0
        currentrow = [currentrow, zeroblock];
        k = k+1;
    endwhile
    coeff = [coeff;currentrow];
    b = [b; points(2, i+1)];
endfor

%derivative rows
for i = 1:(n-2)
    currentrow = [];
    j = i;
    while (j-1)>0
        currentrow = [currentrow, zeroblock];
        j = j -1;
    endwhile
    currentrow = [currentrow, fprime(points(1,i+1)), -1*fprime(points(1,i+1))];
    k = i;
    while (n - 3 - (k-1))>0
        currentrow = [currentrow, zeroblock];
        k = k+1;
    endwhile
    coeff = [coeff;currentrow];
    b = [b;0];
endfor

%second derivative rows
for i = 1:(n-2)
    currentrow = [];
    j = i;
    while (j-1)>0
        currentrow = [currentrow, zeroblock];
        j = j -1;
    endwhile
    currentrow = [currentrow, fpprime(points(1,i+1)), -1*fpprime(points(1,i+1))];
    k = i;
    while (n - 3 - (k-1))>0
        currentrow = [currentrow, zeroblock];
        k = k+1;
    endwhile
    coeff = [coeff;currentrow];
    b = [b;0];
endfor

%endpoint conditions (natural spline)
left = [fpprime(points(1,1)), zeros(1, 4*(n-2))];
right = [zeros(1, 4*(n-2)), fpprime(points(1, end))];

coeff = [coeff; left; right];
b = [b;0;0];

A = [coeff, b];
soln = rref(A)(:,end);
############################################
#The third section plots the interpolation.

scatter(points(1,:), points(2,:), 400)
hold on
for i = 1:(n-1)
    X = points(1,i):.01:points(1,i+1);
    Y = polyval(soln(4*i-3:4*i)', X);
    plot(X,Y)
endfor
</script></div></section></section></div></main>
</div>
<div class="login-link"><span id="loginlogout" class="login">login</span></div>
<script src="https://pretextbook.org/js/0.12/login.js"></script>
</body>
</html>
